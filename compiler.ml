#use "code-gen.ml";;

let file_to_string f =
  let ic = open_in f in
  let s = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;

let string_to_asts s = List.map Semantics.run_semantics
                         (Tag_Parser.tag_parse_expressions
                            (Reader.read_sexprs s));;

let primitive_names_to_labels =Code_Gen.primitive_names_to_labels;;
let rec find_addres_const consts_tbl const= (match consts_tbl with
                                            |[]-> failwith "Faile"
                                            |(exp, (add,_))::tl-> if(exp=const) then add else find_addres_const tl const )

let rec find_index_in_tbl fvars_tbl const=(match fvars_tbl with
                                          |[]-> failwith "Faile"
                                          |(exp,add)::tl->if(exp=const) then add else find_index_in_tbl tl const )
let make_prologue consts_tbl fvars_tbl =
  let get_const_address const = find_addres_const consts_tbl const  in
  let get_fvar_address const = let index = (find_index_in_tbl fvars_tbl const) in
                            Printf.sprintf " Get_FVAR(%d)" index in
  let make_primitive_closure (prim, label) =
"   MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
    mov qword " ^ (get_fvar_address prim)  ^ ", rax" in
  let make_constant (c, (a, s)) = s in

"
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"

global main
section .bss
malloc_pointer:
    resq 1

section .data
const_tbl:
" ^ (String.concat "\n" (List.map make_constant consts_tbl)) ^ "

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS " ^ get_const_address Void ^ "
%define SOB_NIL_ADDRESS " ^ get_const_address (Sexpr Nil) ^ "
%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "

fvar_tbl:
" ^ (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "

section .text
main:
    push rbp ; main rbp
    mov rbp,rsp
    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push qword SOB_NIL_ADDRESS
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED

    jmp code_fragment

code_fragment:
    push rbp
    mov rbp,rsp
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
" ^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels))^"\n";;

let epilogue =file_to_string "epilouge.s"

exception X_missing_input_file;;

try
  let infile = Sys.argv.(1) in
  let code = (file_to_string "stdlib.scm") ^ (file_to_string infile) in
  let asts = string_to_asts code in
  let consts_tbl = Code_Gen.make_consts_tbl asts in
  let fvars_tbl = Code_Gen.make_fvars_tbl asts in
  let generate = Code_Gen.generate consts_tbl fvars_tbl in
  let code_fragment = String.concat "\n\n"
                        (List.map
                           (fun ast -> (generate ast) ^ "\n    call write_sob_if_not_void\n")
                           asts) in
  let provided_primitives = file_to_string "prims.s" in

  print_string ((make_prologue consts_tbl fvars_tbl)  ^
                  code_fragment ^
                  "\tadd rsp,4*8
                  \tpop rbp
                  \tmov rdi,1
                  \tcall exit
                  \n" ^
                    provided_primitives ^ "\n" ^ epilogue)

with Invalid_argument(x) -> raise X_missing_input_file;;
